<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>niwi.nz : Why GraphQL uses string based templates for queries?</title>
    <meta name="viewport" content="width=200, initial-scale=1" />
  <meta name="desciption" content="I&#39;ve followed the graphql development from its public announcement and at first I had my doubts about it, but over time I found the main idea very interesting. However I could not stop asking myself: why string based templates are still used for representing the query language? Since the usage of SQL, is well known that strings are not composable or easily transformable. As much as I try to reason about it, it doesn&#39;t make sense for me. The SQL already suffers from that and there are..." />
    <meta name="author" content="Andrey Antukh" />

    <link rel="stylesheet" href="https://niwi.nz/theme/css/main.css" />

      <link href="https://niwi.nz/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="niwi.nz Atom Feed" />


  </head>

  <body>
    <main>
  <header>
    <a class="back" href="https://niwi.nz"><< back</a>
    <h1>
      <a href="https://niwi.nz/2017/03/01/why-graphql-uses-string-based-templates-for-queries/" id="page-title">Why GraphQL uses string based templates for queries?</a>
    </h1>
    <div class="article-meta">
        <small class="time">
          Date:
          <time datetime="2017-03-01T00:00:00+00:00">
            Wed 01 March 2017
          </time>
        </small>
      <br />
      <small class="tags">
        Tags:
          <a href="https://niwi.nz/tag/graphql.html">graphql,           </a>
          <a href="https://niwi.nz/tag/rant.html">rant,           </a>
          <a href="https://niwi.nz/tag/clojure.html">clojure          </a>
      </small>

      <br />
      <small class="tags">
        Author:
          <span>Andrey Antukh</span>      </small>
    </div>
  </header>
  <article>
    <p>I've followed the graphql development from its public announcement
and at first I had my doubts about it, but over time I found the main
idea very interesting. However I could not stop asking myself: <strong>why
string based templates are still used for representing the query language?</strong></p>
<p>Since the usage of SQL, is well known that strings are not composable
or easily transformable. As much as I try to reason about it, it
doesn't make sense for me. The SQL already suffers from that and there
are many SQL-DSL libraries trying to solve it in some manner.</p>
<p><strong>Why again we made a new language that has exactly the same
problems that SQL?</strong></p>
<p>Additionally to that, we have a new templating language that we need
to learn and deal with its idiosyncrasies. I'm not pretty convinced if
that brings something of value.</p>
<p>But in the end, is just <strong>yet another</strong> very limited template
language that has string interpolation and
some <a href="http://graphql.org/learn/queries/#directives">strange way to include conditionals</a>.</p>
<p>Please don't get me wrong, GraphQL is full of very very good ideas, it
is just that the implementation is not so good as the main idea. And
to be a little bit constructive I'll try to expose my ideas around
the main idea of the GraphQL.</p>
<p>In my vision of that, I think that the query should be represented by
something more composable and transformable. A great example would be
just using the plain data structures that the programming lenguage can
offer.</p>
<p>Let see a graphql query (as string) that I will use as reference in
following examples:</p>
<div class="highlight"><pre><span></span><code><span class="s">&quot;{</span>
<span class="s">  human(id: $id) {</span>
<span class="s">    name</span>
<span class="s">    height(unit: FOOT)</span>
<span class="s">    friends {</span>
<span class="s">      name</span>
<span class="s">    }</span>
<span class="s">  }</span>
<span class="s">  hero(id: $heroId) {</span>
<span class="s">    name</span>
<span class="s">  }</span>
<span class="s">}&quot;</span>
</code></pre></div>

<p>And this is an example of a possible representation of the same query
but using clojure plain data structures:</p>
<div class="highlight"><pre><span></span><code><span class="p">[[</span><span class="ss">:human</span> <span class="p">{</span><span class="ss">:id</span> <span class="s">&quot;1000&quot;</span><span class="p">}</span>
  <span class="p">[</span><span class="ss">:name</span>
   <span class="p">[</span><span class="ss">:height</span> <span class="p">{</span><span class="ss">:unit</span> <span class="ss">:foot</span><span class="p">}]</span>
   <span class="p">[</span><span class="ss">:friends</span> <span class="p">[</span><span class="ss">:name</span><span class="p">]]]]</span>
 <span class="p">[</span><span class="ss">:hero</span> <span class="p">{</span><span class="ss">:id</span> <span class="s">&quot;2000&quot;</span><span class="p">}</span>
  <span class="p">[</span><span class="ss">:name</span><span class="p">]]]</span>
</code></pre></div>

<p>Obviously it is not to be clojure coupled, and can be easy represented
with plain javascript plain data structures:</p>
<div class="highlight"><pre><span></span><code><span class="p">[[</span><span class="s2">&quot;human&quot;</span> <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mf">1000</span><span class="p">}</span>
  <span class="p">[</span><span class="s2">&quot;name&quot;</span>
   <span class="p">[</span><span class="s2">&quot;height&quot;</span> <span class="p">{</span><span class="nx">unit</span><span class="o">:</span> <span class="s2">&quot;FOOT&quot;</span><span class="p">}]</span>
   <span class="p">[</span><span class="s2">&quot;friends&quot;</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]]]</span>
 <span class="p">[</span><span class="s2">&quot;hero&quot;</span> <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="s2">&quot;2000&quot;</span><span class="p">}</span>
  <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]]</span>
</code></pre></div>

<p>The main advantage of using something like this is that we neither need to
learn any new language nor additional directives to perform
conditionals. We just need the same (already familiar) tools that the
language offers for data transformation.</p>
<p>This is not rocket science and nothing new, <strong>React</strong> already uses the
same idea, replacing templates with javascript for create virtual dom
data structures. <strong>There is no magic.</strong></p>
<p>On the server side we can still use the same logic to interpret those
queries as with graphql with the exception that we don't need
implement a new parser, we just need to use the language tools to
interpret that queries <strong>this time, without the not necessary parsing step</strong>.</p>
<p>In conclusion, I think we can learn a lot from GraphQL, it has a lot
of new and refreshing ideas but we need to thing to solve the current
pains instead just repeating them. Probably, on the near future I'll
try take some time for create a prototype of something like what I
have explained.</p>
  </article>
      </div>
    </main>
  </body>
</html>