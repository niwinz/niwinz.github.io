<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>niwi.nz : Promises and ClojureScript</title>
    <meta name=viewport content='width=200, initial-scale=1'>

  <meta name="desciption" content="Updated: 2016-03-22 When I start developing in ClojureScript one year ago, core.async was ( and surelly continues to be) the most adopted library for work with asynchronous code. It is not very bad approach because core.async is a great library, but in my opion is not a good abstraction for represent a result of async computation because it does not has builtin mechanism for handling errors. Due to no existence of well established, documented and high performance promise library for..." />
    <meta name="author" content="Andrey Antukh" />

    <link rel="stylesheet" href="https://www.niwi.nz/theme/css/main.css" />

      <link href="https://www.niwi.nz/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="niwi.nz Atom Feed" />

      <link href="https://www.niwi.nz/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="niwi.nz RSS Feed" />

    <!--[if IE]>
        <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!--[if lte IE 7]>
        <link rel="stylesheet" type="text/css" media="all" href="https://www.niwi.nz/css/ie.css"/>
        <script src="https://www.niwi.nz/js/IE8.js" type="text/javascript"></script>
    <![endif]-->

    <!--[if lt IE 7]>
        <link rel="stylesheet" type="text/css" media="all" href="https://www.niwi.nz/css/ie6.css"/>
    <![endif]-->
  </head>

  <body>
    <div id="wrap">
      <div id="container">

        <div class="entry">
  <header>
    <a href="https://www.niwi.nz"><small>(return to home)</small></a>
    <h1>
      <a href="https://www.niwi.nz/2015/03/28/promises-and-clojurescript/" id="page-title">Promises and ClojureScript</a>
    </h1>
    <div class="article-meta">
        <small class="time">
          Date:
          <time datetime="2015-03-28T00:00:00+00:00">
            Sat 28 March 2015
          </time>
        </small>
      <br />
      <small class="tags">
        Tags:
          <a href="https://www.niwi.nz/tag/clojure.html">clojure,           </a>
          <a href="https://www.niwi.nz/tag/clojurescript.html">clojurescript          </a>
      </small>

      <br />
      <small class="tags">
        Author:
          <span>Andrey Antukh</span>      </small>
    </div>
  </header>
  <article>
    <div id="article-content">
      <p>Updated: 2016-03-22</p>
<p>When I start developing in ClojureScript one year ago, <em>core.async</em> was (
and surelly continues to be) the most adopted library for work with
asynchronous code.</p>
<p>It is not very bad approach because <em>core.async</em> is a great library,
but in my opion is not a good abstraction for represent a result of async
computation because it does not has builtin mechanism for handling
errors.</p>
<p>Due to no existence of well established, documented and high performance
promise library for clojurescript until today, I have written <a href="https://github.com/funcool/promesa">promesa</a>.</p>
<p>It uses the the powerful and high performant <a href="https://github.com/petkaantonov/bluebird/">bluebird</a> promise library
as underlying implementation for ClojureScript and jdk8 completable futures
as underlying impl. for Clojure.</p>
<p>This is a quick preview of the api</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">promesa.core</span> <span class="ss">:as</span> <span class="nv">p</span><span class="p">])</span>

<span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">p/all</span> <span class="p">[(</span><span class="nf">do-some-async-job</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">do-some-other-async-job</span><span class="p">)])</span>
     <span class="p">(</span><span class="nf">p/map</span> <span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">result1</span> <span class="nv">result2</span><span class="p">]]</span>
              <span class="p">(</span><span class="nf">do-stuff</span> <span class="nv">result1</span> <span class="nv">result2</span><span class="p">)))</span>
     <span class="p">(</span><span class="nf">p/err</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">error</span><span class="p">]</span>
              <span class="p">(</span><span class="nf">do-something-with-error</span> <span class="nv">error</span><span class="p">))))</span>
</code></pre></div>

<p>Other of the amazing things that <em>promesa</em> library exposes, is the ability
to compose async computations that looks synchronous:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="kd">defn </span><span class="nv">do-stuff</span>
  <span class="p">[]</span>
  <span class="p">(</span><span class="nf">p/alet</span> <span class="p">[</span><span class="nv">x</span> <span class="p">(</span><span class="nf">p/await</span> <span class="p">(</span><span class="nf">p/promise</span> <span class="mi">1</span><span class="p">))</span>   <span class="c1">;; do async operation</span>
           <span class="nv">_</span> <span class="p">(</span><span class="nf">p/await</span> <span class="p">(</span><span class="nf">p/delay</span> <span class="mi">1000</span><span class="p">))</span>  <span class="c1">;; emulate sleep</span>
           <span class="nv">y</span> <span class="p">(</span><span class="nf">p/await</span> <span class="p">(</span><span class="nf">p/promise</span> <span class="mi">2</span><span class="p">))]</span>  <span class="c1">;; do an other async operation</span>
    <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>                          <span class="c1">;; do the operation with results</span>
                                       <span class="c1">;; of previous two async operations</span>

<span class="p">(</span><span class="nf">p/map</span> <span class="o">#</span><span class="p">(</span><span class="nb">println </span><span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="nf">do-stuff</span><span class="p">))</span>
</code></pre></div>

<p>The result of <code>alet</code> expression is an other promise that will be resolved with result
of final operation or rejected in case of one of its operations is rejected.</p>
<p>This post only shows a little portion of the available api. If you want know more, the
<em>promesa</em> <a href="http://funcool.github.io/promesa/latest/">documentation</a> has a lot of examples.</p>
    </div>
  </article>
        </div>
      </div>

    </div>
  </body>
</html>