<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>niwi.nz : Dealing with persistence with jdbc in asynchronous environments (with clojure)</title>
    <meta name=viewport content='width=200, initial-scale=1'>

  <meta name="desciption" content="Is well known that in async environments, nothing can be blocking. Asynchronous environments uses different approach for handling high concurrently: instead of using a &#34;thread per connection&#34; it uses a limited number of threads for handle thousands of connections, almost always with help with an event loop for handle IO. In that situations, making blocking operations in one thread, is more harmful. Is not same thing block 1 of 200 threads and block 1 of 4 threads (as example). In..." />
    <meta name="author" content="Andrey Antukh" />

    <link rel="stylesheet" href="https://www.niwi.nz/theme/css/main.css" />

      <link href="https://www.niwi.nz/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="niwi.nz Atom Feed" />

      <link href="https://www.niwi.nz/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="niwi.nz RSS Feed" />

    <!--[if IE]>
        <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!--[if lte IE 7]>
        <link rel="stylesheet" type="text/css" media="all" href="https://www.niwi.nz/css/ie.css"/>
        <script src="https://www.niwi.nz/js/IE8.js" type="text/javascript"></script>
    <![endif]-->

    <!--[if lt IE 7]>
        <link rel="stylesheet" type="text/css" media="all" href="https://www.niwi.nz/css/ie6.css"/>
    <![endif]-->
  </head>

  <body>
    <div id="wrap">
      <div id="container">

        <div class="entry">
  <header>
    <a href="https://www.niwi.nz"><small>(return to home)</small></a>
    <h1>
      <a href="https://www.niwi.nz/2015/03/07/dealing-with-persistence-in-async-environments/" id="page-title">Dealing with persistence with jdbc in asynchronous environments (with clojure)</a>
    </h1>
    <div class="article-meta">
        <small class="time">
          Date:
          <time datetime="2015-03-07T00:00:00+00:00">
            Sat 07 March 2015
          </time>
        </small>
      <br />
      <small class="tags">
        Tags:
          <a href="https://www.niwi.nz/tag/clojure.html">clojure,           </a>
          <a href="https://www.niwi.nz/tag/persistence.html">persistence,           </a>
          <a href="https://www.niwi.nz/tag/jdbc.html">jdbc          </a>
      </small>

      <br />
      <small class="tags">
        Author:
          <span>Andrey Antukh</span>      </small>
    </div>
  </header>
  <article>
    <div id="article-content">
      <p>Is well known that in async environments, nothing can be blocking. Asynchronous environments
uses different approach for handling high concurrently: instead of using a "thread per connection"
it uses a limited number of threads for handle thousands of connections, almost always with help
with an event loop for handle IO.</p>
<p>In that situations, making blocking operations in one thread, is more harmful. Is not same thing
block 1 of 200 threads and block 1 of 4 threads (as example).</p>
<p>In case of persistence and concretely jdbc, the api is totally blocking.</p>
<p>The jdbc api is build with threaded environment in the mind. And very often I found people
that thinking that some part of jdbc implementation is bound to the thread using thread locals.
But, the only thing that we should take care with jdbc and concurrency, is that we should not use
the same connection from different threads at same time. That operation is not safe.</p>
<p>The good approach for dealing with blocking calls in async environments is having a separate group
of workers (thread pool) for execute them, allowing to the main threads stay not blocking.</p>
<h2>How I have done it in suricatta?</h2>
<p>Having clear the constrains, I have implemented async support for <em>suricatta</em>.</p>
<p><a href="https://github.com/niwibe/suricatta"><em>Suricatta</em></a> is a toolkit (build on top of fantastic
<a href="http://www.jooq.org/">jOOQ</a> java library) for work with sql in clojure, that allows build, format
and execute sql. It uses jdbc in its internals.</p>
<p>For implement the async support in <em>suricatta</em>, this three main pieces are used: agents, monads and
core.async. Agents and its internals provides a threadpool and serializable operations semantics,
core.async provides an abstraction for avoid callbacks and the <em>exception</em> monad for error handling.</p>
<p>In <em>suricatta</em>, each connection maintains an agent as part of it internal state. This allows guarantee
that all async operations over one connections are done in serializable way (one operation at time).
Having one agent per connection avoid possible bottlenecks if you are using multiple connections
at same time in different parts of your application.</p>
<p>Let's go to see an example:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.core.async</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">&lt;!</span> <span class="nv">go</span><span class="p">]]</span>
         <span class="o">&#39;</span><span class="p">[</span><span class="nv">surricata.core</span> <span class="ss">:as</span> <span class="nv">sc</span><span class="p">]</span>
         <span class="o">&#39;</span><span class="p">[</span><span class="nv">suricatta.async</span> <span class="ss">:as</span> <span class="nv">sa</span><span class="p">])</span>

<span class="p">(</span><span class="k">def </span><span class="nv">dbspec</span> <span class="p">{</span><span class="ss">:subprotocol</span> <span class="s">&quot;h2&quot;</span>
             <span class="ss">:subname</span> <span class="s">&quot;mem:&quot;</span><span class="p">})</span>

<span class="p">(</span><span class="nf">go</span>
  <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">ctx</span> <span class="p">(</span><span class="nf">sc/context</span> <span class="nv">dbspec</span><span class="p">)]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">result</span> <span class="p">(</span><span class="nf">&lt;!</span> <span class="p">(</span><span class="nf">sa/fetch</span> <span class="s">&quot;select 1 as x;&quot;</span><span class="p">))]</span>
      <span class="p">(</span><span class="nb">println </span><span class="s">&quot;Result:&quot;</span> <span class="o">@</span><span class="nv">result</span><span class="p">))))</span>
<span class="c1">;; =&gt; &quot;Result:&quot; [{:x 1}]</span>
</code></pre></div>

<p>A <em>result</em> is an instance of <em>exception</em> monad (from <a href="https://github.com/funcool/cats">cats</a> library),
if you are not familiar with monads, you can treat it as container that can contain a
value or an exception and extract value from it using clojure's <code>deref</code> function or <code>@</code> reader macro.</p>
<p>Maybe, you have a question, that approach is valid for use with transactions?</p>
<p>The response is: <em>Yes</em>. The jdbc maintains transaction state directly in a connection, without
using something like thread locals. There an example of use transactions in with async operations:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nf">go</span>
  <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">ctx</span> <span class="p">(</span><span class="nf">sc/context</span> <span class="nv">dbspec</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">sc/atomic</span> <span class="nv">ctx</span>
      <span class="p">(</span><span class="nf">&lt;!</span> <span class="p">(</span><span class="nf">sa/execute</span> <span class="s">&quot;insert into foo (n) values (1);&quot;</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">&lt;!</span> <span class="p">(</span><span class="nf">sa/execute</span> <span class="s">&quot;insert into foo (n) values (2);&quot;</span><span class="p">)))))</span>
</code></pre></div>

<h2>Final notes</h2>
<p>Clojure and clojure ecosystem comes with great abstractions for different concurrency models, and
this allows an easy way for creating an abstraction for dealing with blocking apis in asynchronous
environments.</p>
<p>This apporoach is not an optimization, this will not make your async api faster. It just allows
properly use jdbc persistence in you async based environments.</p>
    </div>
  </article>
        </div>
      </div>

    </div>
  </body>
</html>