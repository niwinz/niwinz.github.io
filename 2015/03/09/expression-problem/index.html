<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>niwi.nz : The expression problem</title>
    <meta name="viewport" content="width=200, initial-scale=1" />
  <meta name="desciption" content="The Expression problem is a new name to an old problem. In my opinon, you probably do not care about it until know it. This article tries make a little and practical introduction to expression problem situations and explain how them can be elegantly solved using clojure polymorphic constructions. Concretely, protocols. A little introduction Let start with an hypotetical exercise: we are developing an xmpp client, using third party XMPP library for connect to xmpp server. XMPP has different..." />
    <meta name="author" content="Andrey Antukh" />

    <link rel="stylesheet" href="https://niwi.nz/theme/css/main.css" />

      <link href="https://niwi.nz/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="niwi.nz Atom Feed" />


  </head>

  <body>
    <main>
  <header>
    <a class="back" href="https://niwi.nz"><< back</a>
    <h1>
      <a href="https://niwi.nz/2015/03/09/expression-problem/" id="page-title">The expression problem</a>
    </h1>
    <div class="article-meta">
        <small class="time">
          Date:
          <time datetime="2015-03-09T00:00:00+00:00">
            Mon 09 March 2015
          </time>
        </small>
      <br />
      <small class="tags">
        Tags:
          <a href="https://niwi.nz/tag/clojure.html">clojure          </a>
      </small>

      <br />
      <small class="tags">
        Author:
          <span>Andrey Antukh</span>      </small>
    </div>
  </header>
  <article>
    <p>The <em>Expression problem</em> is a new name to an old problem.</p>
<p>In my opinon, you probably do not care about it until know it. This article tries make a little
and practical introduction to expression problem situations and explain how them can be elegantly
solved using clojure polymorphic constructions. Concretely, protocols.</p>
<h2>A little introduction</h2>
<p>Let start with an hypotetical exercise: we are developing an xmpp client, using third party XMPP
library for connect to xmpp server. XMPP has different entities, but for our example we will
use this two: <code>RosterItem</code> and <code>Jid</code>.</p>
<p>Here a little description of these two types:</p>
<ul>
<li>The <code>RosterItem</code> represents an entry in the address book.</li>
<li>The <code>Jid</code> represents a user identity.</li>
</ul>
<p>Both them shares almost all fields and represents a User entity. In the XMPP terminology they have
different semantics but for out purposes is a simply <code>User</code> and we use it in interchangeably way.</p>
<p>Here a hypothetical data type (class) that represents a <code>RosterItem</code></p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RosterItem</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span> <span class="c1">// &quot;niwi&quot;</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">domain</span> <span class="c1">// &quot;niwi.be&quot;</span>
  <span class="kd">public</span> <span class="n">SubscriptionType</span> <span class="n">subscriptionType</span>
<span class="o">}</span>
</code></pre></div>

<p>Here a hypothetical data type (class) that represents a <code>Jid</code></p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Jid</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">local</span> <span class="c1">// &quot;niwi&quot;</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">domain</span> <span class="c1">// &quot;niwi.be&quot;</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">resource</span> <span class="c1">// &quot;mypc&quot;</span>
<span class="o">}</span>
</code></pre></div>

<p>And there are our constraints:</p>
<ul>
<li>We need treat that data types like a User data type in almost all out code base.</li>
<li>We need interact in a simply way with the third party library.</li>
<li>We need a common abstraction for access in a "polymorphic way" to properties.</li>
<li>We can not change the source code, because is a third party library.</li>
</ul>
<h2>Potential solutions</h2>
<h3>Inheritance from common superclass</h3>
<p>The traditional object-oriented solution to problems of this sort is to leverage subtype
polymorphism â€” that is, inheritance.</p>
<p>We need that our user can be represented in two different ways: bare and full. For it,
ideally, both classes would implement an interface like this:</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IUser</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">getName</span><span class="o">()</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">getBare</span><span class="o">()</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">getFull</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div>

<p>But it is not an option because we need modify the source code of third party library. Obviously
we can create a subclass that extends the library types and implement the desired interface, but
this not solves that the library stills returning own types and not your subtypes.</p>
<h3>Multiple inheritance</h3>
<p>Another approach to the Expression Problem is multiple inheritance, in which one subclass can extend
many superclasses.</p>
<p>Here a pseudocode:</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="n">User</span> <span class="kd">extends</span> <span class="n">RosterItem</span><span class="o">,</span> <span class="n">Jid</span> <span class="kd">implements</span> <span class="n">IUser</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">getName</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* implementation */</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">getBare</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* implementation */</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">getFull</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* implementation */</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p>But we known that multiple inheritance has its own problems. It leads to complex and sometimes
unpredictable class hierarchies, and in my opinion should be avoided. Additionally, is not very
common feature in programming languages, that limits a lot the usage of that technique.</p>
<p>Concretelly, java and jvm languages does not support for multiple inheritance. Because of it,
this is also not an solution for out problem.</p>
<h3>Wrappers</h3>
<p>This is a one of the most popular solutions for handle the expression problem in object oriented
languages and sometimes is treated as "the solution".</p>
<p>Let see an example using groovy language:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// MyRosterItem.groovy</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyRosterItem</span> <span class="kd">implements</span> <span class="n">IUser</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="kd">private</span> <span class="n">RosterItem</span> <span class="n">rosterItem</span>
  <span class="kd">public</span> <span class="n">MyRosterItem</span><span class="o">(</span><span class="kd">final</span> <span class="n">RosterItem</span> <span class="n">rosterItem</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">rosterItem</span> <span class="o">=</span> <span class="n">rosterItem</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">getName</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* implementation */</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">getBare</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* implementation */</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">getFull</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* implementation */</span> <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// MyJid.groovy</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyJid</span> <span class="kd">implements</span> <span class="n">IUser</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="kd">private</span> <span class="n">Jid</span> <span class="n">jid</span>
  <span class="kd">public</span> <span class="n">MyJid</span><span class="o">(</span><span class="kd">final</span> <span class="n">Jid</span> <span class="n">jid</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">jid</span> <span class="o">=</span> <span class="n">jid</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">getName</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* implementation */</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">getBare</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* implementation */</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">getFull</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* implementation */</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p>But this solution has a huge number of inconveniences:</p>
<ul>
<li><em>It breaks the identity</em>. You can not use an instance of your roster item as parameter to the third
  party library that you are using for connect with XMPP. You should constanctly wrapping and
  unwrapping, and this adds a lot of additional accidental complexity.</li>
<li>You can't compare a <code>MyJid</code> with <code>Jid</code> with <code>==</code> operator.</li>
<li>You can't use <code>Object.equals</code> because it should be symetric. If you want compate an MyJid instance
  with some other <code>Jid</code> instance, you should explicitly wrap the second one for make the compatation.</li>
<li>If you want that you <code>MyJid</code> type behaves exactly that <code>Jid</code>, you should implement a proxy
  for all public methods of <code>Jid</code> class. That can be very tedious if <code>Jid</code> implements something
  like <code>List</code> interface (or any other with huge number of methods).</li>
</ul>
<p>In my opinion, wrappers is not good solution for expression problem and requires a lot of unnecesary
work.</p>
<h3>Open Classes</h3>
<p>Consists in that a class can be reopened by anyone and at any time to add new methods.</p>
<p>This approach is popularized mainly by Ruby and JavaScript languages and it has similar problems that
multiple inheritance: not all languages supports it.</p>
<p>Example of open classes using ruby language:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">String</span>
  <span class="k">def</span> <span class="nf">write_size</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">size</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="nb">puts</span> <span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">write_size</span>
</code></pre></div>

<p>This approach also solves the problem, but in my opinion adds more problems that solves:</p>
<ul>
<li>It breaks namespacing (like any other solution exposed previously)</li>
<li>Easy name clashing. You have no way of knowing that some other user of that class won't define
  a different and incompatible method with same name.</li>
</ul>
<p>This technique is also known as "Monkey patching" and is well known that is not a good design pattern
for your software.</p>
<h3>Traits</h3>
<p>This is very very similar to openclasses, the unique difference is that is more safe. Because
if name clashing is happens, the compiller will notify about it and will abort the compilation.</p>
<p>Here an example of traits usage using rust language:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">Dog</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span> <span class="kt">str</span> <span class="p">}</span><span class="w"></span>

<span class="k">trait</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">noise</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span> <span class="kt">str</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">noise</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span> <span class="kt">str</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;woof!&quot;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<h3>Static methods with conditionals</h3>
<p>This is other most common approaches to the expression problem. It consists in create a helper
class with static methods that uses conditionals (on type).</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Utils</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">getName</span><span class="o">(</span><span class="kd">final</span> <span class="n">Object</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">source</span> <span class="k">instanceof</span> <span class="n">RosterItem</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* implementation */</span> <span class="o">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">source</span> <span class="k">instanceof</span> <span class="n">Jid</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* implementation */</span> <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span> <span class="k">throw</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s2">&quot;Invalid source.&quot;</span><span class="o">);</span> <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p>But in this case, we are not extending the type. We simply create a simple static funcion that
works on concrete type. This approach tends to grow into not maintainable code and obliges
modify the defined func in case you want extend it with new cases.</p>
<p>Additionally, it not performs very well.</p>
<h3>Static methods with overloading</h3>
<p>This is an improvement over the previous case. Consists on using overloads instead of conditionals.</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Utils</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">getName</span><span class="o">(</span><span class="kd">final</span> <span class="n">RosterItem</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* implementation */</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">getName</span><span class="o">(</span><span class="kd">final</span> <span class="n">Jid</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* implementation */</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p>This approach solves the performance problem and add an other: it becomes unpredictable
in the face of complex inheritance hierarchies.</p>
<h2>The clojure approach</h2>
<p>Clojure is designed and written in terms of abstractions and in difference with java or
other popular languages, has different approach for work with abstractions. Like haskell (and maybe
other funcional languages), it has clear separation between types (data), abstraction (protocol),
and implementation.</p>
<p><em>Protocols</em> are conceptually very similar to java "interfaces" but only supports the best
parts of them. They provides a high-performance, dynamic polymorphism construct with ability
to extend type out of design time.</p>
<p>This is a possible aspect of our abstraction represented using a clojure protocol:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="kd">ns </span><span class="nv">myapp.protocols</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defprotocol </span><span class="nv">IUser</span>
  <span class="s">&quot;Common abstraction for access to user like objects.&quot;</span>
  <span class="p">(</span><span class="nf">get-name</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="s">&quot;Get user name.&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">get-bare</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="s">&quot;Get bare representation of user&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">get-full</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="s">&quot;Get full representation of user&quot;</span><span class="p">))</span>
</code></pre></div>

<p>The next step consists in add an implementation of this protocol for our
hypothetical types. This can be done using <code>extend-type</code> function. Clojure also
exposes other helpers but for our purposes <code>extend-type</code> fits perfectly.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="kd">ns </span><span class="nv">myapp.core</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">myapp.protocols</span> <span class="ss">:as</span> <span class="nv">impl</span><span class="p">])</span>
  <span class="p">(</span><span class="ss">:import</span> <span class="nv">somelib.roster.RosterItem</span>
           <span class="nv">somelib.jid.Jid</span><span class="p">))</span>

<span class="p">(</span><span class="nf">extend-type</span> <span class="nv">RosterItem</span>
  <span class="nv">impl/IUser</span>
  <span class="p">(</span><span class="nf">get-name</span> <span class="p">[</span><span class="nv">o</span><span class="p">]</span> <span class="p">(</span><span class="nf">.-name</span> <span class="nv">o</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">get-bare</span> <span class="p">[</span><span class="nv">o</span><span class="p">]</span> <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nf">.-name</span> <span class="nv">o</span><span class="p">)</span> <span class="s">&quot;@&quot;</span> <span class="p">(</span><span class="nf">.-domain</span> <span class="nv">o</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">get-full</span> <span class="p">[</span><span class="nv">o</span><span class="p">]</span> <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nf">.-name</span> <span class="nv">o</span><span class="p">)</span> <span class="s">&quot;@&quot;</span> <span class="p">(</span><span class="nf">.-domain</span> <span class="nv">o</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">extend-type</span> <span class="nv">Jid</span>
  <span class="nv">impl/IUser</span>
  <span class="p">(</span><span class="nf">get-name</span> <span class="p">[</span><span class="nv">o</span><span class="p">]</span> <span class="p">(</span><span class="nf">.-local</span> <span class="nv">o</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">get-bare</span> <span class="p">[</span><span class="nv">o</span><span class="p">]</span> <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nf">.-local</span> <span class="nv">o</span><span class="p">)</span> <span class="s">&quot;@&quot;</span> <span class="p">(</span><span class="nf">.-domain</span> <span class="nv">o</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">get-full</span> <span class="p">[</span><span class="nv">o</span><span class="p">]</span> <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nf">.-local</span> <span class="nv">o</span><span class="p">)</span> <span class="s">&quot;@&quot;</span> <span class="p">(</span><span class="nf">.-domain</span> <span class="nv">o</span><span class="p">)</span> <span class="s">&quot;/&quot;</span> <span class="p">(</span><span class="nf">.-resource</span> <span class="nv">o</span><span class="p">))))</span>
</code></pre></div>

<p>As I have said previously, protocols exposes a namespaced functions. This avoid completely the risk
of name clashing if some other have implemented one method with same name. And the best part: no
identity lose, you can work over your abstractions together with thrird party types without modifying
them.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">jid</span> <span class="p">(</span><span class="nf">Jid.</span> <span class="s">&quot;niwi&quot;</span> <span class="s">&quot;niwi.be&quot;</span> <span class="s">&quot;mypc&quot;</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">println </span><span class="s">&quot;Result: &quot;</span> <span class="p">(</span><span class="nf">impl/get-bare</span> <span class="nv">jid</span><span class="p">)))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ritem</span> <span class="p">(</span><span class="nf">RosterItem.</span> <span class="s">&quot;niwi2&quot;</span> <span class="s">&quot;niwi.be&quot;</span> <span class="ss">:both</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">println </span><span class="s">&quot;Result: &quot;</span> <span class="p">(</span><span class="nf">impl/get-bare</span> <span class="nv">ritem</span><span class="p">)))</span>
</code></pre></div>

<p>Clojure offers very flexible polymorphic constructions that makes the code more expressive
without additional accidental complexity. If protocols seems limited for you, let try use
<em>multimethods</em>.</p>
  </article>
      </div>
    </main>
  </body>
</html>