<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>niwi.nz : Fetching and aggregating data from remote sources with Urania</title>
    <meta name=viewport content='width=200, initial-scale=1'>

  <meta name="desciption" content="The problem Oftentimes, our software relies on fetching and aggregating data from remote sources. Be it a database, an API exposed via HTTP or another protocol, the filesystem, or a cache. Remote data sources often have latency associated to them, and there may be unavailable due to network conditions. When implementing business logic relying on remote data sources, we often have to complect many concerns: The actual data transformation and aggregation Fetching the data optimally for..." />
    <meta name="author" content="Alejandro Gómez" />

    <link rel="stylesheet" href="https://niwi.nz/theme/css/main.css" />

      <link href="https://niwi.nz/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="niwi.nz Atom Feed" />

      <link href="https://niwi.nz/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="niwi.nz RSS Feed" />

    <!--[if IE]>
        <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!--[if lte IE 7]>
        <link rel="stylesheet" type="text/css" media="all" href="https://niwi.nz/css/ie.css"/>
        <script src="https://niwi.nz/js/IE8.js" type="text/javascript"></script>
    <![endif]-->

    <!--[if lt IE 7]>
        <link rel="stylesheet" type="text/css" media="all" href="https://niwi.nz/css/ie6.css"/>
    <![endif]-->
  </head>

  <body>
    <div id="wrap">
      <div id="container">

        <div class="entry">
  <header>
    <a href="https://niwi.nz"><small>(return to home)</small></a>
    <h1>
      <a href="https://niwi.nz/2016/03/05/fetching-and-aggregating-remote-data-with-urania/" id="page-title">Fetching and aggregating data from remote sources with Urania</a>
    </h1>
    <div class="article-meta">
        <small class="time">
          Date:
          <time datetime="2016-03-05T00:00:00+00:00">
            Sat 05 March 2016
          </time>
        </small>
      <br />
      <small class="tags">
        Tags:
          <a href="https://niwi.nz/tag/clojure.html">clojure,           </a>
          <a href="https://niwi.nz/tag/clojurescript.html">clojurescript,           </a>
          <a href="https://niwi.nz/tag/remote-data.html">remote data          </a>
      </small>

      <br />
      <small class="tags">
        Author:
          <span>Alejandro Gómez</span>      </small>
    </div>
  </header>
  <article>
    <div id="article-content">
      <h2>The problem</h2>
<p>Oftentimes, our software relies on fetching and aggregating data from remote sources. Be it a database,
an API exposed via HTTP or another protocol, the filesystem, or a cache. Remote data sources often have
latency associated to them, and there may be unavailable due to network conditions.</p>
<p>When implementing business logic relying on remote data sources, we often have to complect many concerns:</p>
<ul>
<li>The actual data transformation and aggregation</li>
<li>Fetching the data optimally for minimizing latency<ul>
<li>Deduplication</li>
<li>Caching</li>
<li>Batching</li>
</ul>
</li>
<li>Detecting and handling errors<ul>
<li>Performing retries</li>
<li>Using timeouts for aborting fetches</li>
</ul>
</li>
</ul>
<p>All of this can make us trade code clarity for performance, and our business logic gets buried in low-level
details.</p>
<h3>Enter Urania</h3>
<p><a href="https://github.com/funcool/urania">Urania</a> makes your business logic relying on remote data sources efficient and free of the minutiae of optimization
and error handling. It achieves this goals with two core ideas:</p>
<ul>
<li>Using the Promise type available in <a href="https://github.com/funcool/promesa">Promesa</a> for conveying asynchronous values which can fail</li>
<li>Separating the declaration of a fetch from its interpretation and applying optimizations when interpreted</li>
</ul>
<h2>Case study</h2>
<p>We'll be using a few Clojure libraries for the example, you can use the following <code>project.clj</code> if you want to run
the code:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="kd">defproject </span><span class="nv">hello-urania</span> <span class="s">&quot;0.1.0&quot;</span>
  <span class="ss">:dependencies</span> <span class="p">[[</span><span class="nv">org.clojure/clojure</span> <span class="s">&quot;1.7.0&quot;</span><span class="p">]</span>
                 <span class="p">[</span><span class="nv">funcool/urania</span> <span class="s">&quot;0.1.0&quot;</span><span class="p">]</span>
                 <span class="p">[</span><span class="nv">funcool/promesa</span> <span class="s">&quot;0.8.1&quot;</span><span class="p">]</span>
                 <span class="p">[</span><span class="nv">funcool/httpurr</span> <span class="s">&quot;0.5.0-SNAPSHOT&quot;</span><span class="p">]</span>
                 <span class="p">[</span><span class="nv">org.clojure/data.json</span> <span class="s">&quot;0.2.6&quot;</span><span class="p">]</span>
                 <span class="p">[</span><span class="nv">aleph</span> <span class="s">&quot;0.4.1-beta4&quot;</span><span class="p">]</span>
                 <span class="p">[</span><span class="nv">funcool/suricatta</span> <span class="s">&quot;0.8.1&quot;</span><span class="p">]</span>
                 <span class="p">[</span><span class="nv">org.postgresql/postgresql</span> <span class="s">&quot;9.4-1204-jdbc42&quot;</span><span class="p">]])</span>
</code></pre></div>

<p>Imagine that we are running a website which has a relational database and stores the information about its users in
there. We are exposing an API for asking several questions about our users, for example their GitHub username. These
queries will have to fetch data from our relational DB, as well as from GitHub and potentially other sources.</p>
<p>We want to make these queries composable, efficient, and free of the details of asynchronous data fetching and we'll use
Urania to achieve that. First of all, we are going to create our relational database. We'll be using the <a href="https://github.com/funcool/suricatta">suricatta</a> library
for running SQL queries against a PostgreSQL db:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">suricatta.core</span> <span class="ss">:as</span> <span class="nv">sc</span><span class="p">])</span>

<span class="p">(</span><span class="k">def </span><span class="nv">dbspec</span> <span class="p">{</span><span class="ss">:subprotocol</span> <span class="s">&quot;postgresql&quot;</span>
             <span class="ss">:subname</span> <span class="s">&quot;//localhost:5432/urania&quot;</span><span class="p">})</span>

<span class="p">(</span><span class="k">def </span><span class="nv">db</span> <span class="p">(</span><span class="nf">sc/context</span> <span class="nv">dbspec</span><span class="p">))</span>
</code></pre></div>

<p>We create and populate our only table: users.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nf">sc/execute</span> <span class="nv">db</span>
            <span class="s">&quot;CREATE TABLE users (</span>
<span class="s">               id BIGSERIAL PRIMARY KEY,</span>
<span class="s">               githubid VARCHAR(255) UNIQUE NOT NULL</span>
<span class="s">             )&quot;</span><span class="p">)</span>
<span class="c1">;; =&gt; 0</span>

<span class="p">(</span><span class="nf">sc/execute</span> <span class="nv">db</span>
            <span class="s">&quot;INSERT INTO users (githubid) VALUES (&#39;dialelo&#39;);&quot;</span><span class="p">)</span>
<span class="c1">;; =&gt; 1</span>
</code></pre></div>

<p>And now we can fetch users from the DB:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nf">sc/fetch-one</span> <span class="nv">db</span>
              <span class="p">[</span><span class="s">&quot;SELECT * from users where id = ?&quot;</span> <span class="mi">1</span><span class="p">])</span>
<span class="c1">;; =&gt; {:id 1, :githubid &quot;dialelo&quot;}</span>
</code></pre></div>

<p>We now have a way to fetch a user given its id, which is very nice, but it will return <code>nil</code> if the user is not
found thus limiting its composability. Also, the query is executed synchronously, and we may want to perform it
in a separate thread.</p>
<p>Let's define a data source for the users of our database. When the user is not found, it will return a rejected
promise and if its found it will simply resolve the promise with the user data:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">promesa.core</span> <span class="ss">:as</span> <span class="nv">prom</span><span class="p">])</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">urania.core</span> <span class="ss">:as</span> <span class="nv">u</span><span class="p">])</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print!</span>
  <span class="p">[</span><span class="nv">thing</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nb">pr-str </span><span class="nv">thing</span><span class="p">)</span> <span class="sc">\n</span><span class="nv">ewline</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">deftype </span><span class="nv">User</span> <span class="p">[</span><span class="nv">id</span><span class="p">]</span>
  <span class="nv">u/DataSource</span>
  <span class="p">(</span><span class="nf">-identity</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="nv">id</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">-fetch</span> <span class="p">[</span><span class="nv">_</span> <span class="p">{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">db</span><span class="p">]}]</span>
    <span class="p">(</span><span class="nf">print!</span> <span class="p">[</span><span class="ss">:-&gt;user</span> <span class="nv">id</span><span class="p">])</span>
    <span class="p">(</span><span class="nf">prom/promise</span>
      <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nb">resolve </span><span class="nv">reject</span><span class="p">]</span>
        <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">usr</span> <span class="p">(</span><span class="nf">sc/fetch-one</span> <span class="nv">db</span>
                                 <span class="p">[</span><span class="s">&quot;SELECT * from users where id = ?&quot;</span> <span class="nv">id</span><span class="p">])]</span>
         <span class="p">(</span><span class="nf">do</span>
           <span class="p">(</span><span class="nf">print!</span> <span class="p">[</span><span class="ss">:&lt;-user</span> <span class="nv">usr</span><span class="p">])</span>
           <span class="p">(</span><span class="nb">resolve </span><span class="nv">usr</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">reject</span> <span class="p">(</span><span class="nf">ex-info</span> <span class="s">&quot;User not found&quot;</span> <span class="p">{</span><span class="ss">:id</span> <span class="nv">id</span><span class="p">})))))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">user</span>
  <span class="p">[</span><span class="nv">id</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">User.</span> <span class="nv">id</span><span class="p">))</span>
</code></pre></div>

<p>Now, we can ask for users given their id. Notice how we inject the db connection when running a fetch:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nf">u/run!!</span> <span class="p">(</span><span class="nf">user</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="ss">:env</span> <span class="p">{</span><span class="ss">:db</span> <span class="nv">db</span><span class="p">}})</span>
<span class="c1">;; [:-&gt;user 1]</span>
<span class="c1">;; [:&lt;-user {:id 1, :githubid dialelo}]</span>
<span class="c1">;; =&gt; {:id 1, :githubid &quot;dialelo&quot;}</span>
</code></pre></div>

<p>If we try to fetch a user that doesn't exist, we get back a rejected promise. Lets take a look:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">def </span><span class="nv">fetch</span> <span class="p">(</span><span class="nf">u/run!</span> <span class="p">(</span><span class="nf">user</span> <span class="mi">99</span><span class="p">)</span> <span class="p">{</span><span class="ss">:env</span> <span class="p">{</span><span class="ss">:db</span> <span class="nv">db</span><span class="p">}}))</span>

<span class="p">(</span><span class="nf">deref</span>
  <span class="p">(</span><span class="nf">prom/catch</span> <span class="nv">fetch</span>
              <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">err</span><span class="p">]</span>
                <span class="p">{</span><span class="ss">:msg</span> <span class="p">(</span><span class="nf">.getMessage</span> <span class="nv">err</span><span class="p">)</span>
                 <span class="ss">:data</span> <span class="p">(</span><span class="nf">ex-data</span> <span class="nv">err</span><span class="p">)})))</span>
<span class="c1">;; [:-&gt;user 99]</span>
<span class="c1">;; =&gt; {:msg &quot;User not found&quot;, :data {:id 99}}</span>
</code></pre></div>

<p>In the above example, we use promesa's <code>catch</code> combinator to transform an exception thrown inside a rejected promise
to a resolved promise which contains a data strutcture with information about the error.</p>
<p>We can ask the first question about our users: given a user id, give me its GitHub username.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="kd">defn </span><span class="nv">github-username-by-id</span>
  <span class="p">[</span><span class="nv">id</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">u/map</span> <span class="ss">:githubid</span> <span class="p">(</span><span class="nf">user</span> <span class="nv">id</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">u/run!!</span> <span class="p">(</span><span class="nf">github-username-by-id</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="ss">:env</span> <span class="p">{</span><span class="ss">:db</span> <span class="nv">db</span><span class="p">}})</span>
<span class="c1">;; [:-&gt;user 1]</span>
<span class="c1">;; [:&lt;-user {:id 1, :githubid dialelo}]</span>
<span class="c1">;; =&gt; &quot;dialelo&quot;</span>
</code></pre></div>

<p>We can now fetch our users but we want to ask questions about their GitHub activity so we'll need a way to fetch GitHub
user information. For that we use GitHub's API, you'll need a GitHub OAuth token for running these examples. We'll use
the <a href="https://github.com/funcool/httpurr">httpurr</a> Clojure(Script) HTTP client to communicate with GitHub. First of all, let's define the headers we are going to
use and the response parsing code:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.data.json</span> <span class="ss">:as</span> <span class="nv">json</span><span class="p">])</span>

<span class="p">(</span><span class="k">def </span><span class="nv">github-token</span> <span class="s">&quot;bring-your-own-token&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">github-headers</span> <span class="p">{</span><span class="s">&quot;User-Agent&quot;</span> <span class="s">&quot;httpurr&quot;</span>
                     <span class="s">&quot;Content-Type&quot;</span> <span class="s">&quot;application/json&quot;</span>
                     <span class="s">&quot;Authorization&quot;</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;token &quot;</span> <span class="nv">github-token</span><span class="p">)})</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">parse-response</span>
  <span class="p">[</span><span class="nv">response</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">response</span>
    <span class="ss">:body</span>
    <span class="nv">slurp</span>
   <span class="p">(</span><span class="nf">json/read-str</span> <span class="ss">:key-fn</span> <span class="nv">keyword</span><span class="p">)))</span>
</code></pre></div>

<p>Now we're able to define a data source for github users:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">httpurr.client</span> <span class="ss">:as</span> <span class="nv">http</span><span class="p">])</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">github-user-url</span>
  <span class="p">[</span><span class="nv">username</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">str </span><span class="s">&quot;https://api.github.com/users/&quot;</span> <span class="nv">username</span><span class="p">))</span>

<span class="p">(</span><span class="kd">deftype </span><span class="nv">GitHubUser</span> <span class="p">[</span><span class="nv">username</span><span class="p">]</span>
  <span class="nv">u/DataSource</span>
  <span class="p">(</span><span class="nf">-identity</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="nv">username</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">-fetch</span> <span class="p">[</span><span class="nv">_</span> <span class="p">{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">http</span><span class="p">]}]</span>
    <span class="p">(</span><span class="nf">print!</span> <span class="p">[</span><span class="ss">:-&gt;github-user</span> <span class="nv">username</span><span class="p">])</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">req</span> <span class="p">(</span><span class="nf">http/send!</span> <span class="nv">http</span>
                          <span class="p">{</span><span class="ss">:method</span> <span class="ss">:get</span>
                           <span class="ss">:url</span> <span class="p">(</span><span class="nf">github-user-url</span> <span class="nv">username</span><span class="p">)</span>
                           <span class="ss">:headers</span> <span class="nv">github-headers</span><span class="p">})]</span>
       <span class="p">(</span><span class="nf">prom/then</span> <span class="nv">req</span> <span class="o">#</span><span class="p">(</span><span class="nf">do</span>
                         <span class="p">(</span><span class="nf">print!</span> <span class="p">[</span><span class="ss">:&lt;-github-user</span> <span class="nv">username</span><span class="p">])</span>
                         <span class="p">(</span><span class="nf">parse-response</span> <span class="nv">%</span><span class="p">))))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">github-user</span>
  <span class="p">[</span><span class="nv">username</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">GitHubUser.</span> <span class="nv">username</span><span class="p">))</span>
</code></pre></div>

<p>Now that we have two data sources we can start asking more interesting questions about our data, let's give it a spin. We'll
start with a simple query: given a user ID from our database, give me its GitHub user information. Note how we build this
query on top of a previous one: <code>github-username-by-id</code>:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">httpurr.client.aleph</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">client</span><span class="p">]])</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">github-user-by-id</span>
  <span class="p">[</span><span class="nv">id</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">u/mapcat</span> <span class="nv">github-user</span> <span class="p">(</span><span class="nf">github-username-by-id</span> <span class="nv">id</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">u/run!!</span> <span class="p">(</span><span class="nf">github-user-by-id</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="ss">:env</span> <span class="p">{</span><span class="ss">:db</span> <span class="nv">db</span>, <span class="ss">:http</span> <span class="nv">client</span><span class="p">}})</span>
<span class="c1">;; [:-&gt;user 1]</span>
<span class="c1">;; [:&lt;-user {:id 1, :githubid dialelo}]</span>
<span class="c1">;; [:-&gt;github-user dialelo]</span>
<span class="c1">;; [:&lt;-github-user dialelo]</span>
<span class="c1">;; =&gt; {:html_url &quot;https://github.com/dialelo&quot;, :disk_usage 604079, ... }</span>
</code></pre></div>

<p>Since our <code>github-user</code> returns a fetch to perform we have used <code>urania.core/mapcat</code> instead of <code>urania.core/map</code>.</p>
<p>We can now start asking questions about the GitHub account of our users, for example how many followers they have:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="kd">defn </span><span class="nv">github-follower-count-by-id</span>
  <span class="p">[</span><span class="nv">id</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">u/map</span> <span class="ss">:followers</span> <span class="p">(</span><span class="nf">github-user-by-id</span> <span class="nv">id</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">u/run!!</span> <span class="p">(</span><span class="nf">github-follower-count-by-id</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="ss">:env</span> <span class="p">{</span><span class="ss">:db</span> <span class="nv">db</span>, <span class="ss">:http</span> <span class="nv">client</span><span class="p">}})</span>
<span class="c1">;; [:-&gt;user 1]</span>
<span class="c1">;; [:&lt;-user {:id 1, :githubid dialelo}]</span>
<span class="c1">;; [:-&gt;github-user dialelo]</span>
<span class="c1">;; [:&lt;-github-user dialelo]</span>
<span class="c1">;; =&gt; 186</span>
</code></pre></div>

<p>Or we can even merge the data from our database with the account info on GitHub.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="kd">defn </span><span class="nv">db-and-github-user</span>
  <span class="p">[</span><span class="nv">id</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">u/map</span> <span class="o">#</span><span class="p">(</span><span class="nb">merge </span><span class="nv">%1</span> <span class="nv">%2</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">user</span> <span class="nv">id</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">github-user-by-id</span> <span class="nv">id</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">u/run!!</span> <span class="p">(</span><span class="nf">db-and-github-user</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="ss">:env</span> <span class="p">{</span><span class="ss">:db</span> <span class="nv">db</span>, <span class="ss">:http</span> <span class="nv">client</span><span class="p">}})</span>
<span class="c1">;; [:-&gt;user 1]</span>
<span class="c1">;; [:&lt;-user {:id 1, :githubid dialelo}]</span>
<span class="c1">;; [:-&gt;github-user dialelo]</span>
<span class="c1">;; [:&lt;-github-user dialelo]</span>
<span class="c1">;; =&gt; {:html_url &quot;https://github.com/dialelo&quot;, :githubid &quot;dialelo&quot;, ... }</span>
</code></pre></div>

<p>Notice that we call <code>(user id)</code> both in <code>db-and-github-user</code> function's body and inside <code>github-user-by-id</code> but is
only fetched once. This deduplication that urania does for you alows you to write code like the remote data is residing
in memory.</p>
<p>Now that we are going to ask questions about the organization a user belongs to, so we need to define another data source
for fetching a user's organizations:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">def </span><span class="nv">github-user-orgs-url</span> <span class="s">&quot;https://api.github.com/user/orgs&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="kd">deftype </span><span class="nv">UserOrgs</span> <span class="p">[</span><span class="nv">username</span><span class="p">]</span>
  <span class="nv">u/DataSource</span>
  <span class="p">(</span><span class="nf">-identity</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="nv">username</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">-fetch</span> <span class="p">[</span><span class="nv">_</span> <span class="p">{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">http</span><span class="p">]}]</span>
    <span class="p">(</span><span class="nf">print!</span> <span class="p">[</span><span class="ss">:-&gt;github-user-orgs</span> <span class="nv">username</span><span class="p">])</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">req</span> <span class="p">(</span><span class="nf">http/send!</span> <span class="nv">http</span>
                          <span class="p">{</span><span class="ss">:method</span> <span class="ss">:get</span>
                           <span class="ss">:url</span> <span class="nv">github-user-orgs-url</span>
                           <span class="ss">:headers</span> <span class="nv">github-headers</span><span class="p">})]</span>
      <span class="p">(</span><span class="nf">prom/then</span> <span class="nv">req</span> <span class="o">#</span><span class="p">(</span><span class="nf">do</span>
                       <span class="p">(</span><span class="nf">print!</span> <span class="p">[</span><span class="ss">:&lt;-github-user-orgs</span> <span class="nv">username</span><span class="p">])</span>
                       <span class="p">(</span><span class="nf">parse-response</span> <span class="nv">%</span><span class="p">))))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">github-user-orgs</span>
  <span class="p">[</span><span class="nv">username</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">UserOrgs.</span> <span class="nv">username</span><span class="p">))</span>
</code></pre></div>

<p>Let's ask for the organizations of a certain user now:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="kd">defn </span><span class="nv">github-orgs-by-user-id</span>
  <span class="p">[</span><span class="nv">id</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">u/mapcat</span> <span class="nv">github-user-orgs</span> <span class="p">(</span><span class="nf">github-username-by-id</span> <span class="nv">id</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">u/run!!</span> <span class="p">(</span><span class="nf">u/map</span> <span class="nb">count </span><span class="p">(</span><span class="nf">github-orgs-by-user-id</span> <span class="mi">1</span><span class="p">))</span>
         <span class="p">{</span><span class="ss">:env</span> <span class="p">{</span><span class="ss">:db</span> <span class="nv">db</span>, <span class="ss">:http</span> <span class="nv">client</span><span class="p">}})</span>
<span class="c1">;; [:-&gt;user 1]</span>
<span class="c1">;; [:&lt;-user {:id 1, :githubid dialelo}]</span>
<span class="c1">;; [:-&gt;github-user-orgs dialelo]</span>
<span class="c1">;; [:&lt;-github-user-orgs dialelo]</span>
<span class="c1">;; =&gt; 14</span>
</code></pre></div>

<p>Or augment a GitHub user's data with their organizations:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="kd">defn </span><span class="nv">github-user-with-orgs-by-id</span>
  <span class="p">[</span><span class="nv">id</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">u/map</span> <span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="ss">:orgs</span> <span class="nv">%2</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">github-user-by-id</span> <span class="nv">id</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">github-orgs-by-user-id</span> <span class="nv">id</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">u/run!!</span> <span class="p">(</span><span class="nf">github-user-with-orgs-by-id</span> <span class="mi">1</span><span class="p">)</span>
         <span class="p">{</span><span class="ss">:env</span> <span class="p">{</span><span class="ss">:db</span> <span class="nv">db</span>, <span class="ss">:http</span> <span class="nv">client</span><span class="p">}})</span>
<span class="c1">;; [:&lt;-user {:id 1, :githubid &quot;dialelo&quot;}]</span>
<span class="c1">;; [:-&gt;github-user &quot;dialelo&quot;]</span>
<span class="c1">;; [:-&gt;github-user-orgs &quot;dialelo&quot;]</span>
<span class="c1">;; [:&lt;-github-user &quot;dialelo&quot;]</span>
<span class="c1">;; [:&lt;-github-user-orgs &quot;dialelo&quot;]</span>
<span class="c1">;; =&gt; {:html_url &quot;https://github.com/dialelo&quot;, :disk_usage 604079 ... }</span>
</code></pre></div>

<p>Notice how both the GitHub user and its organizations are fetched concurrently.</p>
<p>In the age of microservices, many utility function have been refactored to microservices. It's the case of our Uppercase
microservice, which takes a word and returns it uppercased. In the first iteration of our uppercase microservice it is
only available to uppercase one word at a time, let's define a data source for it:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="kd">defrecord </span><span class="nv">Uppercase</span> <span class="p">[</span><span class="nv">string</span><span class="p">]</span>
  <span class="nv">u/DataSource</span>
  <span class="p">(</span><span class="nf">-identity</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="nv">string</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">-fetch</span> <span class="p">[</span><span class="nv">_</span> <span class="nv">_</span><span class="p">]</span>
    <span class="p">(</span><span class="nf">print!</span> <span class="p">[</span><span class="ss">:-&gt;uppercase-string</span> <span class="nv">string</span><span class="p">])</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">uppercased</span> <span class="p">(</span><span class="nf">.toUpperCase</span> <span class="nv">string</span><span class="p">)]</span>
      <span class="p">(</span><span class="nf">print!</span> <span class="p">[</span><span class="ss">:&lt;-uppercase-string</span> <span class="nv">uppercased</span><span class="p">])</span>
      <span class="p">(</span><span class="nf">prom/resolved</span> <span class="nv">uppercased</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">uppercase</span>
  <span class="p">[</span><span class="nv">str</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">Uppercase.</span> <span class="nv">str</span><span class="p">))</span>
</code></pre></div>

<p>We now want to know the uppercased name of every GitHub organization a user belongs to, so let's write that query:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="kd">defn </span><span class="nv">uppercased-github-org-names</span>
  <span class="p">[</span><span class="nv">id</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">u/traverse</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">org</span><span class="p">]</span>
                <span class="p">(</span><span class="nf">uppercase</span> <span class="p">(</span><span class="ss">:login</span> <span class="nv">org</span><span class="p">)))</span>
              <span class="p">(</span><span class="nf">github-orgs-by-user-id</span> <span class="nv">id</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">u/run!!</span> <span class="p">(</span><span class="nf">uppercased-github-org-names</span> <span class="mi">1</span><span class="p">)</span>
         <span class="p">{</span><span class="ss">:env</span> <span class="p">{</span><span class="ss">:db</span> <span class="nv">db</span>, <span class="ss">:http</span> <span class="nv">client</span><span class="p">}})</span>
<span class="c1">;; [:-&gt;user 1]</span>
<span class="c1">;; [:&lt;-user {:id 1, :githubid &quot;dialelo&quot;}]</span>
<span class="c1">;; [:-&gt;github-user-orgs &quot;dialelo&quot;]</span>
<span class="c1">;; [:&lt;-github-user-orgs &quot;dialelo&quot;]</span>
<span class="c1">;; [:-&gt;uppercase-string &quot;kaleidos&quot;]</span>
<span class="c1">;; [:-&gt;uppercase-string &quot;Front-Guerrilla&quot;]</span>
<span class="c1">;; [:&lt;-uppercase-string &quot;FRONT-GUERRILLA&quot;]</span>
<span class="c1">;; [:&lt;-uppercase-string &quot;KALEIDOS&quot;]</span>
<span class="c1">;; [:-&gt;uppercase-string &quot;wikimaps&quot;]</span>
<span class="c1">;; [:-&gt;uppercase-string &quot;uxbox&quot;]</span>
<span class="c1">;; [:-&gt;uppercase-string &quot;47deg&quot;]</span>
<span class="c1">;; [:&lt;-uppercase-string &quot;UXBOX&quot;]</span>
<span class="c1">;; [:&lt;-uppercase-string &quot;47DEG&quot;]</span>
<span class="c1">;; [:-&gt;uppercase-string &quot;sloth&quot;]</span>
<span class="c1">;; [:&lt;-uppercase-string &quot;WIKIMAPS&quot;]</span>
<span class="c1">;; [:&lt;-uppercase-string &quot;SLOTH&quot;]</span>
<span class="c1">;; [:-&gt;uppercase-string &quot;thefinalcountapp&quot;]</span>
<span class="c1">;; [:-&gt;uppercase-string &quot;taigaio&quot;]</span>
<span class="c1">;; [:-&gt;uppercase-string &quot;mammutdb&quot;]</span>
<span class="c1">;; [:&lt;-uppercase-string &quot;TAIGAIO&quot;]</span>
<span class="c1">;; [:&lt;-uppercase-string &quot;THEFINALCOUNTAPP&quot;]</span>
<span class="c1">;; [:-&gt;uppercase-string &quot;funcool&quot;]</span>
<span class="c1">;; [:-&gt;uppercase-string &quot;Emacs-Madrid&quot;]</span>
<span class="c1">;; [:&lt;-uppercase-string &quot;FUNCOOL&quot;]</span>
<span class="c1">;; [:&lt;-uppercase-string &quot;EMACS-MADRID&quot;]</span>
<span class="c1">;; [:-&gt;uppercase-string &quot;clojurecup2014&quot;]</span>
<span class="c1">;; [:-&gt;uppercase-string &quot;opensourcedesign&quot;]</span>
<span class="c1">;; [:&lt;-uppercase-string &quot;CLOJURECUP2014&quot;]</span>
<span class="c1">;; [:&lt;-uppercase-string &quot;OPENSOURCEDESIGN&quot;]</span>
<span class="c1">;; [:-&gt;uppercase-string &quot;PIWEEK&quot;]</span>
<span class="c1">;; [:&lt;-uppercase-string &quot;PIWEEK&quot;]</span>
<span class="c1">;; [:&lt;-uppercase-string &quot;MAMMUTDB&quot;]</span>
<span class="c1">;; =&gt; [&quot;47DEG&quot; &quot;KALEIDOS&quot; &quot;WIKIMAPS&quot; &quot;OPENSOURCEDESIGN&quot; &quot;PIWEEK&quot; &quot;FRONT-GUERRILLA&quot; &quot;EMACS-MADRID&quot; &quot;TAIGAIO&quot; &quot;MAMMUTDB&quot; &quot;CLOJURECUP2014&quot; &quot;THEFINALCOUNTAPP&quot; &quot;FUNCOOL&quot; &quot;SLOTH&quot; &quot;UXBOX&quot;]</span>
</code></pre></div>

<p>Whoa, that's a lot of requests to our uppercase microservice. Since we are having problems scaling it we have implemented
a batch API, we can now uppercase words in batches! We update our data source to take advantage of the batch API:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nf">extend-type</span> <span class="nv">Uppercase</span>
  <span class="nv">u/BatchedSource</span>
  <span class="p">(</span><span class="nf">-fetch-multi</span> <span class="p">[</span><span class="nb">up </span><span class="nv">ups</span> <span class="nv">_</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">all-strs</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="ss">:string</span> <span class="nv">up</span><span class="p">)</span> <span class="p">(</span><span class="nb">map </span><span class="ss">:string</span> <span class="nv">ups</span><span class="p">))</span>
          <span class="nv">uppercased</span> <span class="p">(</span><span class="nf">mapv</span> <span class="o">#</span><span class="p">(</span><span class="nf">.toUpperCase</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">all-strs</span><span class="p">)]</span>
      <span class="p">(</span><span class="nf">print!</span> <span class="p">[</span><span class="ss">:-&gt;uppercase-strings</span> <span class="nv">all-strs</span><span class="p">])</span>
      <span class="p">(</span><span class="nf">print!</span> <span class="p">[</span><span class="ss">:&lt;-uppercase-strings</span> <span class="nv">uppercased</span><span class="p">])</span>
      <span class="p">(</span><span class="nf">prom/resolved</span> <span class="p">(</span><span class="nb">zipmap </span><span class="nv">all-strs</span> <span class="nv">uppercased</span><span class="p">)))))</span>
</code></pre></div>

<p>And notice how re-runing the query takes advantage of the batch API:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nf">u/run!!</span> <span class="p">(</span><span class="nf">uppercased-github-org-names</span> <span class="mi">1</span><span class="p">)</span>
         <span class="p">{</span><span class="ss">:env</span> <span class="p">{</span><span class="ss">:db</span> <span class="nv">db</span>, <span class="ss">:http</span> <span class="nv">client</span><span class="p">}})</span>
<span class="c1">;; [:-&gt;user 1]</span>
<span class="c1">;; [:&lt;-user {:id 1, :githubid &quot;dialelo&quot;}]</span>
<span class="c1">;; [:-&gt;github-user-orgs &quot;dialelo&quot;]</span>
<span class="c1">;; [:&lt;-github-user-orgs &quot;dialelo&quot;]</span>
<span class="c1">;; [:-&gt;uppercase-strings (&quot;kaleidos&quot; &quot;Front-Guerrilla&quot; &quot;wikimaps&quot; &quot;uxbox&quot; &quot;47deg&quot; &quot;sloth&quot; &quot;thefinalcountapp&quot; &quot;mammutdb&quot; &quot;taigaio&quot; &quot;funcool&quot; &quot;Emacs-Madrid&quot; &quot;clojurecup2014&quot; &quot;opensourcedesign&quot; &quot;PIWEEK&quot;)]</span>
<span class="c1">;; [:&lt;-uppercase-strings [&quot;KALEIDOS&quot; &quot;FRONT-GUERRILLA&quot; &quot;WIKIMAPS&quot; &quot;UXBOX&quot; &quot;47DEG&quot; &quot;SLOTH&quot; &quot;THEFINALCOUNTAPP&quot; &quot;MAMMUTDB&quot; &quot;TAIGAIO&quot; &quot;FUNCOOL&quot; &quot;EMACS-MADRID&quot; &quot;CLOJURECUP2014&quot; &quot;OPENSOURCEDESIGN&quot; &quot;PIWEEK&quot;]]</span>
<span class="c1">;; =&gt; [&quot;KALEIDOS&quot; &quot;FRONT-GUERRILLA&quot; &quot;WIKIMAPS&quot; &quot;UXBOX&quot; &quot;47DEG&quot; &quot;SLOTH&quot; &quot;THEFINALCOUNTAPP&quot; &quot;MAMMUTDB&quot; &quot;TAIGAIO&quot; &quot;FUNCOOL&quot; &quot;EMACS-MADRID&quot; &quot;CLOJURECUP2014&quot; &quot;OPENSOURCEDESIGN&quot; &quot;PIWEEK&quot;]</span>
</code></pre></div>

<h2>Conclusion</h2>
<p>Urania helps keep your business logic relying on remote data source elegant and composable, while executing it
efficiently without you having to specify any coordination, deduplication or cahing. It can aggregate data from
a variety of remote data sources, signal and recover from failures, and make your code elegant and efficient.</p>
    </div>
  </article>
        </div>
      </div>

    </div>
  </body>
</html>